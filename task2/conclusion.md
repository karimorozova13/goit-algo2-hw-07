### Аналіз результатів

На основі отриманого графіка можна зробити наступні висновки щодо ефективності двох підходів (LRU Cache та Splay Tree) для обчислення чисел Фібоначчі на великих значеннях **n**:

1. **LRU Cache значно швидший**

   - Використання `@lru_cache` дозволяє зберігати вже обчислені значення, що зменшує кількість повторних рекурсивних викликів.
   - Час виконання майже не зростає з **збільшенням n**, оскільки повторне використання кешованих значень працює ефективно.

2. **Splay Tree демонструє гірші результати**

   - Незважаючи на балансування дерева при кожному запиті, Splay Tree не може забезпечити таку саму швидкість доступу, як `@lru_cache`.
   - Для кожного виклику **доводиться здійснювати пошук у дереві**, що додає додаткові витрати на ротації вузлів.

3. **Поведінка при збільшенні n**
   - Для **малих n** (0–200) різниця між підходами мінімальна, оскільки кількість викликів рекурсії невелика.
   - Починаючи з **n > 500**, **LRU Cache** працює у десятки разів швидше.
   - Для **n = 950** час виконання Splay Tree майже **вдвічі більший**, ніж у LRU Cache.

### Висновок

**LRU Cache є більш ефективним підходом** для обчислення чисел Фібоначчі, оскільки:  
Використовує механізм автоматичного кешування без додаткових структур даних.  
Час виконання залишається стабільно малим навіть для великих **n**.  
Значно перевершує Splay Tree за швидкодією, особливо на **великих значеннях n**.
